name: Nx Cloud Main

on:
  workflow_call:
    inputs:
      init-commands:
        required: false
        type: string
      final-commands:
        required: false
        type: string
      parallel-commands:
        required: false
        type: string
      parallel-commands-on-agents:
        required: false
        type: string
      node-version:
        required: false
        type: string
      yarn-version:
        required: false
        type: string
      npm-version:
        required: false
        type: string
      pnpm-version:
        required: false
        type: string
      install-commands:
        required: false
        type: string
      main-branch-name:
        required: false
        type: string
        default: main
      # We needed this input in order to be able to configure out integration tests for this repo, it is not documented
      # so as to not cause confusion/add noise, but technically any consumer of the workflow can use it if they want to.
      working-directory:
        required: false
        type: string

env:
  NX_CLOUD_DISTRIBUTED_EXECUTION: true
  NX_BRANCH: ${{ github.event.number || github.ref_name }}

jobs:
  main:
    runs-on: ubuntu-latest
    # The name of the job which will invoke this one is expected to be "Nx Cloud - Main Job", and whatever we call this will be appended
    # to that one after a forward slash, so we keep this one intentionally short to produce "Nx Cloud - Main Job / Run" in the Github UI
    name: Run
    defaults:
      run:
        working-directory: ${{ inputs.working-directory || github.workspace }}
    steps:
      - uses: actions/checkout@v2
        name: Checkout [Pull Request]
        if: ${{ github.event_name == 'pull_request' }}
        with:
          # By default, PRs will be checked-out based on the Merge Commit, but we want the actual branch HEAD.
          ref: ${{ github.event.pull_request.head.sha }}
          # We need to fetch all branches and commits so that Nx affected has a base to compare against.
          fetch-depth: 0

      - uses: actions/checkout@v2
        name: Checkout [Default Branch]
        if: ${{ github.event_name != 'pull_request' }}
        with:
          # We need to fetch all branches and commits so that Nx affected has a base to compare against.
          fetch-depth: 0

      - name: Derive appropriate SHAs for base and head for `nx affected` commands
        uses: nrwl/nx-set-shas@v2
        with:
          main-branch-name: ${{ inputs.main-branch-name }}

      # Set node/npm/yarn versions using volta, with optional overrides provided by the consumer
      - uses: volta-cli/action@fdf4cf319494429a105efaa71d0e5ec67f338c6e

      - name: Print node/npm/yarn versions
        id: versions
        run: |
          node_ver=$( node --version )
          yarn_ver=$( yarn --version || true )
          pnpm_ver=$( pnpm --version || true )

          echo "Node: ${node_ver:1}"
          echo "NPM: $( npm --version )"
          if [[ $yarn_ver != '' ]]; then echo "Yarn: $yarn_ver"; fi
          if [[ $pnpm_ver != '' ]]; then echo "PNPM: $pnpm_ver"; fi

          echo "::set-output name=node_version::${node_ver:1}"

      - name: Run any configured install-commands
        if: ${{ inputs.install-commands != '' }}
        run: |
          ${{ inputs.install-commands }}
      - name: Install dependencies
        if: ${{ inputs.install-commands == '' }}
        run: |
          echo "Running yarn"
          yarn

      # An unfortunate side-effect of the way reusable workflows work is that by the time they are pulled into the "caller"
      # repo, they are effectively completely embedded in that context. This means that we cannot reference any files which
      # are local to this repo which defines the workflow, and we therefore need to work around this by embedding the contents
      # of the shell utilities for executing commands into the workflow directly.
      - name: Create command utils
        uses: actions/github-script@v6
        with:
          script: |
            const { writeFileSync } = require('fs');
            const runCommandsInParallelScript = `
              # Extract the provided commands from the stringified JSON array.
              IFS=$'\n' read -d '' -a userCommands < <((jq -c -r '.[]') <<<"$1")

              # Invoke the provided commands in parallel and collect their exit codes.
              pids=()
              for userCommand in "\${userCommands[@]}"; do
                eval "$userCommand" & pids+=($!)
              done

              # If any one of the invoked commands exited with a non-zero exit code, exit the whole thing with code 1.
              for pid in \${pids[*]}; do
                if ! wait $pid; then
                  exit 1
                fi
              done

              # All the invoked commands must have exited with code zero.
              exit 0
            `;
            writeFileSync('./.github/workflows/run-commands-in-parallel.sh', runCommandsInParallelScript);

      - name: Prepare command utils
        run: chmod +x ${{ github.workspace }}/.github/workflows/run-commands-in-parallel.sh

      - name: Initialize the Nx Cloud distributed CI run
        run: npx nx-cloud start-ci-run

      # The good thing about the multi-line string input for sequential commands is that we can simply forward it on as is to the bash shell and it will behave
      # how we want it to in terms of quote escaping, variable assignment etc
      - name: Run any configured init-commands sequentially
        if: ${{ inputs.init-commands != '' }}
        shell: bash
        run: |
          ${{ inputs.init-commands }}

      - name: Process parallel commands configuration
        uses: actions/github-script@v6
        id: parallel_commands_config
        env:
          PARALLEL_COMMANDS: ${{ inputs.parallel-commands }}
          PARALLEL_COMMANDS_ON_AGENTS: ${{ inputs.parallel-commands-on-agents }}
        with:
          # For the ones configured for main, explicitly set NX_CLOUD_DISTRIBUTED_EXECUTION to false, taking into account commands chained with &&
          # within the strings. In order to properly escape single quotes we need to do some manual replacing and escaping so that the commands
          # are forwarded onto the run-commands-in-parallel.sh script appropriately.
          script: |
            const parallelCommandsOnMainStr = process.env.PARALLEL_COMMANDS || '';
            const parallelCommandsOnAgentsStr = process.env.PARALLEL_COMMANDS_ON_AGENTS || '';

            const parallelCommandsOnMain = parallelCommandsOnMainStr
              .split('\n')
              .map(command => command.trim())
              .filter(command => command.length > 0)
              .map(s => s.replace(/'/g, '%27'));
            const parallelCommandsOnAgents = parallelCommandsOnAgentsStr
              .split('\n')
              .map(command => command.trim())
              .filter(command => command.length > 0)
              .map(s => s.replace(/'/g, '%27'));

            const formattedArrayOfCommands = [
              ...parallelCommandsOnMain.map(s => s
                .split(' && ')
                .map(s => `NX_CLOUD_DISTRIBUTED_EXECUTION=false ${s}`)
                .join(' && ')
              ),
              ...parallelCommandsOnAgents,
            ];

            const stringifiedEncodedArrayOfCommands = JSON.stringify(formattedArrayOfCommands)
              .replace(/%27/g, "'\\''");

            return stringifiedEncodedArrayOfCommands
          result-encoding: string

      - name: Run any configured parallel commands on main and agent jobs
        run: ${{ github.workspace }}/.github/workflows/run-commands-in-parallel.sh '${{ steps.parallel_commands_config.outputs.result }}'
        shell: bash

      # The good thing about the multi-line string input for sequential commands is that we can simply forward it on as is to the bash shell and it will behave
      # how we want it to in terms of quote escaping, variable assignment etc
      - name: Run any configured final-commands sequentially
        if: ${{ inputs.final-commands != '' }}
        shell: bash
        run: |
          ${{ inputs.final-commands }}

      - name: Stop all running agents for this CI run
        # It's important that we always run this step, otherwise in the case of any failures in preceding non-Nx steps, the agents will keep running and waste billable minutes
        if: ${{ always() }}
        run: npx nx-cloud stop-all-agents
